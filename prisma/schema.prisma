// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}

// User Management
model User {
  id           Int      @id @default(autoincrement())
  firstName    String   @map("first_name")
  lastName     String   @map("last_name")
  email        String   @unique
  password     String   @map("password_hash")
  phone        String?
  role         UserRole @default(STAFF)
  isActive     Boolean  @default(true) @map("is_active")
  notes        String?
  
  // Authentication & Session
  lastLogin          DateTime? @map("last_login")
  lastLogout         DateTime? @map("last_logout")
  lastActivity       DateTime? @map("last_activity")
  
  // Password Reset
  resetToken         String?   @map("reset_token")
  resetTokenExpires  DateTime? @map("reset_token_expires")
  
  // Email Verification & User Approval
  emailVerified       Boolean   @default(false) @map("email_verified")
  emailVerifiedAt     DateTime? @map("email_verified_at")
  emailVerificationToken String? @map("email_verification_token")
  emailVerificationExpires DateTime? @map("email_verification_expires")
  
  // User Approval Workflow
  userStatus         UserStatus @default(PENDING) @map("user_status")
  approvedBy         Int?      @map("approved_by")
  approvedAt         DateTime? @map("approved_at")
  rejectionReason    String?   @map("rejection_reason")
  
  // Email Preferences
  emailNotifications Boolean   @default(true) @map("email_notifications")
  marketingEmails    Boolean   @default(false) @map("marketing_emails")
  
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  // Relations
  salesTransactions SalesTransaction[]
  stockAdjustments  StockAdjustment[]
  auditLogs         AuditLog[]
  
  // Stock Management Relations
  stockAdditions       StockAddition[]         @relation("StockAdditionCreator")
  createdReconciliations StockReconciliation[] @relation("ReconciliationCreator")
  approvedReconciliations StockReconciliation[] @relation("ReconciliationApprover")
  
  // Self-referential for approval workflow
  approvedUsers     User[] @relation("UserApproval")
  approver          User?  @relation("UserApproval", fields: [approvedBy], references: [id])

  @@map("users")
}

enum UserRole {
  ADMIN
  MANAGER
  STAFF
}

enum UserStatus {
  PENDING       // User registered but email not verified
  VERIFIED      // Email verified but not approved by admin
  APPROVED      // Approved by admin and can access dashboard
  REJECTED      // Rejected by admin
  SUSPENDED     // Temporarily suspended
}

// Supplier Management
model Supplier {
  id            Int      @id @default(autoincrement())
  name          String
  contactPerson String?  @map("contact_person")
  email         String?
  phone         String?
  address       String?
  city          String?
  state         String?
  postalCode    String?  @map("postal_code")
  country       String?  @default("Canada")
  website       String?
  taxNumber     String?  @map("tax_number")
  paymentTerms  String?  @map("payment_terms")
  creditLimit   Decimal? @map("credit_limit") @db.Decimal(10, 2)
  notes         String?
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  products       Product[]
  purchaseOrders PurchaseOrder[]
  stockAdditions StockAddition[]

  @@map("suppliers")
}

// Category Management
model Category {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  products    Product[]

  @@map("categories")
}

// Brand Management
model Brand {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  website     String?
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  products    Product[]

  @@map("brands")
}

// Product Catalog
model Product {
  id               Int               @id @default(autoincrement())
  name             String
  description      String?
  sku              String            @unique
  barcode          String?           @unique
  cost             Decimal           @db.Decimal(10, 2)
  price            Decimal           @db.Decimal(10, 2)
  stock            Int               @default(0)
  minStock         Int               @default(0) @map("min_stock")
  maxStock         Int?              @map("max_stock")
  unit             String            @default("pcs")
  weight           Decimal?          @db.Decimal(8, 3)
  dimensions       String?
  color            String?
  size             String?
  material         String?
  status           ProductStatus     @default(ACTIVE)
  hasVariants      Boolean           @default(false) @map("has_variants")
  isArchived       Boolean           @default(false) @map("is_archived")
  images           Json?             // Array of image URLs
  tags             String[]          @default([])
  metaTitle        String?           @map("meta_title")
  metaDescription  String?           @map("meta_description")
  seoKeywords      String[]          @default([]) @map("seo_keywords")
  createdAt        DateTime          @default(now()) @map("created_at")
  updatedAt        DateTime          @updatedAt @map("updated_at")

  // Relations
  supplier         Supplier?         @relation(fields: [supplierId], references: [id])
  supplierId       Int?              @map("supplier_id")
  category         Category?         @relation(fields: [categoryId], references: [id])
  categoryId       Int?              @map("category_id")
  brand            Brand?            @relation(fields: [brandId], references: [id])
  brandId          Int?              @map("brand_id")
  variants         ProductVariant[]
  stockAdjustments StockAdjustment[]
  salesItems       SalesItem[]
  purchaseOrderItems PurchaseOrderItem[]
  aiContent        AIContent[]
  webflowSync      WebflowSync?
  
  // New Stock Management Relations
  stockAdditions         StockAddition[]
  reconciliationItems    StockReconciliationItem[]

  @@map("products")
}

enum ProductStatus {
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
  DISCONTINUED
}

// Product Variants
model ProductVariant {
  id        Int      @id @default(autoincrement())
  name      String
  sku       String   @unique
  barcode   String?  @unique
  price     Decimal  @db.Decimal(10, 2)
  cost      Decimal  @db.Decimal(10, 2)
  stock     Int      @default(0)
  minStock  Int      @default(0)
  attributes Json    // e.g., {"color": "red", "size": "M"}
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId Int

  stockAdjustments StockAdjustment[]
  salesItems       SalesItem[]

  @@map("product_variants")
}

// Sales Transactions
model SalesTransaction {
  id              Int                 @id @default(autoincrement())
  transactionCode String              @unique
  total           Decimal             @db.Decimal(10, 2)
  subtotal        Decimal             @db.Decimal(10, 2)
  tax             Decimal             @default(0) @db.Decimal(10, 2)
  discount        Decimal             @default(0) @db.Decimal(10, 2)
  discountType    DiscountType        @default(AMOUNT)
  paymentMethod   PaymentMethod
  paymentStatus   PaymentStatus       @default(PENDING)
  customerName    String?
  customerEmail   String?
  customerPhone   String?
  notes           String?
  receiptNumber   String?             @unique
  isRefund        Boolean             @default(false)
  refundReason    String?
  syncedToWebflow Boolean             @default(false)
  syncedAt        DateTime?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations
  cashier     User        @relation(fields: [cashierId], references: [id])
  cashierId   Int
  salesItems  SalesItem[]
  auditLogs   AuditLog[]

  @@map("sales_transactions")
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  POS_MACHINE
  CREDIT_CARD
  MOBILE_MONEY
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
  CANCELLED
}

enum DiscountType {
  AMOUNT
  PERCENTAGE
}

// Sales Items
model SalesItem {
  id         Int     @id @default(autoincrement())
  quantity   Int
  unitPrice  Decimal @db.Decimal(10, 2)
  totalPrice Decimal @db.Decimal(10, 2)
  discount   Decimal @default(0) @db.Decimal(10, 2)
  createdAt  DateTime @default(now())

  // Relations
  transaction   SalesTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  transactionId Int
  product       Product?         @relation(fields: [productId], references: [id])
  productId     Int?
  variant       ProductVariant?  @relation(fields: [variantId], references: [id])
  variantId     Int?

  @@map("sales_items")
}

// Stock Addition - For new stock purchases
model StockAddition {
  id            Int      @id @default(autoincrement())
  quantity      Int
  costPerUnit   Decimal  @db.Decimal(10, 2) @map("cost_per_unit")
  totalCost     Decimal  @db.Decimal(10, 2) @map("total_cost")
  purchaseDate  DateTime @default(now()) @map("purchase_date")
  notes         String?
  referenceNo   String?  @map("reference_no") // Invoice/receipt number
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  product     Product   @relation(fields: [productId], references: [id])
  productId   Int       @map("product_id")
  supplier    Supplier? @relation(fields: [supplierId], references: [id])
  supplierId  Int?      @map("supplier_id")
  createdBy   User      @relation("StockAdditionCreator", fields: [createdById], references: [id])
  createdById Int       @map("created_by")

  @@map("stock_additions")
}

// Stock Reconciliation - For multi-product stock counts with approval
model StockReconciliation {
  id          Int                      @id @default(autoincrement())
  title       String
  description String?
  status      StockReconciliationStatus @default(DRAFT)
  notes       String?
  createdAt   DateTime                 @default(now()) @map("created_at")
  updatedAt   DateTime                 @updatedAt @map("updated_at")
  submittedAt DateTime?                @map("submitted_at")
  approvedAt  DateTime?                @map("approved_at")

  // Relations
  createdBy    User                       @relation("ReconciliationCreator", fields: [createdById], references: [id])
  createdById  Int                        @map("created_by")
  approvedBy   User?                      @relation("ReconciliationApprover", fields: [approvedById], references: [id])
  approvedById Int?                       @map("approved_by")
  items        StockReconciliationItem[]

  @@map("stock_reconciliations")
}

enum StockReconciliationStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
}

// Stock Reconciliation Items - Individual product adjustments within a reconciliation
model StockReconciliationItem {
  id               Int     @id @default(autoincrement())
  systemCount      Int     @map("system_count")    // Current system stock count
  physicalCount    Int     @map("physical_count")  // Actual counted stock
  discrepancy      Int     @map("discrepancy")     // Calculated difference
  discrepancyReason String? @map("discrepancy_reason")
  estimatedImpact  Decimal? @db.Decimal(10, 2) @map("estimated_impact") // Financial impact
  notes           String?

  // Relations
  reconciliation   StockReconciliation @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)
  reconciliationId Int                 @map("reconciliation_id")
  product          Product             @relation(fields: [productId], references: [id])
  productId        Int                 @map("product_id")

  @@map("stock_reconciliation_items")
}

// Stock Management
model StockAdjustment {
  id            Int                 @id @default(autoincrement())
  type          StockAdjustmentType
  quantity      Int
  previousStock Int
  newStock      Int
  reason        String
  notes         String?
  createdAt     DateTime            @default(now())

  // Relations
  user      User            @relation(fields: [userId], references: [id])
  userId    Int
  product   Product?        @relation(fields: [productId], references: [id])
  productId Int?
  variant   ProductVariant? @relation(fields: [variantId], references: [id])
  variantId Int?

  @@map("stock_adjustments")
}

enum StockAdjustmentType {
  INCREASE
  DECREASE
  RECOUNT
  DAMAGE
  TRANSFER
  RETURN
}

// Purchase Orders
model PurchaseOrder {
  id            Int                 @id @default(autoincrement())
  orderNumber   String              @unique
  status        PurchaseOrderStatus @default(PENDING)
  orderDate     DateTime            @default(now())
  expectedDate  DateTime?
  receivedDate  DateTime?
  total         Decimal             @db.Decimal(10, 2)
  notes         String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  // Relations
  supplier Supplier            @relation(fields: [supplierId], references: [id])
  supplierId Int
  items    PurchaseOrderItem[]

  @@map("purchase_orders")
}

enum PurchaseOrderStatus {
  PENDING
  ORDERED
  PARTIAL_RECEIVED
  RECEIVED
  CANCELLED
}

model PurchaseOrderItem {
  id            Int      @id @default(autoincrement())
  quantity      Int
  unitCost      Decimal  @db.Decimal(10, 2)
  totalCost     Decimal  @db.Decimal(10, 2)
  receivedQty   Int      @default(0)
  createdAt     DateTime @default(now())

  // Relations
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  purchaseOrderId Int
  product         Product       @relation(fields: [productId], references: [id])
  productId       Int

  @@map("purchase_order_items")
}

// Audit & Activity Logs
model AuditLog {
  id          Int       @id @default(autoincrement())
  action      String
  entityType  String
  entityId    String
  oldValues   Json?
  newValues   Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime  @default(now())

  // Relations
  user          User?             @relation(fields: [userId], references: [id])
  userId        Int?
  transaction   SalesTransaction? @relation(fields: [transactionId], references: [id])
  transactionId Int?

  @@map("audit_logs")
}

// AI Generated Content
model AIContent {
  id              Int           @id @default(autoincrement())
  type            AIContentType
  prompt          String
  generatedText   String
  status          ContentStatus @default(DRAFT)
  tone            String?
  keywords        String[]      @default([])
  isApproved      Boolean       @default(false)
  approvedAt      DateTime?
  version         Int           @default(1)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  productId Int?
  product   Product? @relation(fields: [productId], references: [id])

  @@map("ai_content")
}

enum AIContentType {
  DESCRIPTION
  SEO_TITLE
  SEO_DESCRIPTION
  SOCIAL_MEDIA_POST
  PRODUCT_FEATURES
  MARKETING_COPY
}

enum ContentStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PUBLISHED
  REJECTED
}

// Webflow Sync
model WebflowSync {
  id            Int              @id @default(autoincrement())
  productId     Int
  webflowItemId String?
  status        WebflowSyncStatus
  lastSyncAt    DateTime?
  syncData      Json?            // Store sync payload
  errorMessage  String?
  retryCount    Int              @default(0)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId])
  @@map("webflow_syncs")
}

enum WebflowSyncStatus {
  PENDING
  SYNCING
  SUCCESS
  FAILED
  RETRY
}
